
extern crate sysfs_gpio;
extern crate spidev;

use sysfs_gpio::{Direction, Pin};
use spidev::{Spidev, SpidevOptions, SPI_MODE_0};
use std::io::Write;
use std::thread::sleep;
use std::time::Duration;

// Port of Adafruit's Nokia LCD library in Python.

const LCDWIDTH  : usize = 84;
const LCDHEIGHT : usize = 48;
const ROWPIXELS : usize = LCDHEIGHT / 6;

const DEFAULT_CONTRAST : u8 = 40;
const DEFAULT_BIAS     : u8 = 4;

const PCD8544_POWERDOWN           : u8 = 0x04;
const PCD8544_ENTRYMODE           : u8 = 0x02;
const PCD8544_EXTENDEDINSTRUCTION : u8 = 0x01;
const PCD8544_DISPLAYBLANK        : u8 = 0x0;
const PCD8544_DISPLAYNORMAL       : u8 = 0x4;
const PCD8544_DISPLAYALLON        : u8 = 0x1;
const PCD8544_DISPLAYINVERTED     : u8 = 0x5;
const PCD8544_FUNCTIONSET         : u8 = 0x20;
const PCD8544_DISPLAYCONTROL      : u8 = 0x08;
const PCD8544_SETYADDR            : u8 = 0x40;
const PCD8544_SETXADDR            : u8 = 0x80;
const PCD8544_SETTEMP             : u8 = 0x04;
const PCD8544_SETBIAS             : u8 = 0x10;
const PCD8544_SETVOP              : u8 = 0x80;

pub struct PCD8544 {
    dc : Pin,
    rst : Pin,
    spi : Spidev,
    buffer : [u8 ; LCDWIDTH * LCDHEIGHT / 8]
}

#[derive(Debug)]
pub enum Error {
    PinError(sysfs_gpio::Error),
    SpiDevError(std::io::Error)
}

impl From<sysfs_gpio::Error> for Error {
    fn from(e : sysfs_gpio::Error) -> Error {
        Error::PinError(e)
    }
}

impl From<std::io::Error> for Error {
    fn from(e : std::io::Error) -> Error {
        Error::SpiDevError(e)
    }
}

type Result<T> = std::result::Result<T, Error>;

fn new_pin(n : u64, dir : Direction, timeout : Duration, retries : u32) -> Result<Pin> {
    let pin = Pin::new(n);

    // Assume the pin will be correctly configured.
    let mut res : Result<Pin> = Ok(pin);

    // Export the sysfs entry for the chosen pin.
    pin.export()?;

    // The sysfs entry might not be immediately usable
    // after the export operation.
    // We will call set_direction() repeatedly until the operation completes
    // or after a given number of attempts.
    for k in 0..retries {
        if k > 0 {
            sleep(timeout);
        }
        match pin.set_direction(dir) {
            Ok(_)  => return Ok(pin),
            Err(e) => res = Err(Error::from(e))
        }
    }

    // Return the last result.
    res
}

impl PCD8544 {
    pub fn new(dc : u64, rst : u64, spi : &str) -> Result<Self> {
        let mut spidev = Spidev::open(spi)?;
        let mut options = SpidevOptions::new();
        options.bits_per_word(8).max_speed_hz(4_000_000).mode(SPI_MODE_0);
        spidev.configure(&options)?;

        let mut res = Self {
            dc  : new_pin(dc,  Direction::Out, Duration::from_millis(100), 3)?,
            rst : new_pin(rst, Direction::Out, Duration::from_millis(100), 3)?,
            spi : spidev,
            buffer : [
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFF, 0xFC, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0xC0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x87, 0x8F, 0x9F, 0x9F, 0xFF, 0xFF, 0xFF, 0xC1, 0xC0, 0xE0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF1, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x0F, 0x0F, 0x87, 0xE7, 0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x3F, 0xF9, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x7E, 0x3F, 0x3F, 0x0F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ] // [0x00 ; LCDWIDTH * LCDHEIGHT / 8]
        };

        res.reset()?;
        res.set_contrast(DEFAULT_CONTRAST)?;
        res.set_bias(DEFAULT_BIAS)?;

        Ok(res)
    }

    pub fn reset(&mut self) -> Result<()> {
        self.rst.set_value(0)?;
        sleep(Duration::from_millis(100));
        self.rst.set_value(1)?;
        Ok(())
    }

    pub fn command(&mut self, c : u8) -> Result<()> {
        self.dc.set_value(0)?;
        self.spi.write(&[c])?;
        Ok(())
    }

    pub fn extended_command(&mut self, c : u8) -> Result<()> {
        // Set extended command mode
        self.command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION)?;
        self.command(c)?;
        // Set normal display mode.
        self.command(PCD8544_FUNCTIONSET)?;
        self.command(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL)?;
        Ok(())
    }

    pub fn data(&mut self, c : u8) -> Result<()> {
        self.dc.set_value(1)?;
        self.spi.write(&[c])?;
        Ok(())
    }

    pub fn set_contrast(&mut self, contrast : u8) -> Result<()> {
        let mut c = contrast;
        if c > 127 {
            c = 127;
        }
        self.extended_command(PCD8544_SETVOP | c)?;
        Ok(())
    }

    pub fn set_bias(&mut self, bias : u8) -> Result<()> {
        self.extended_command(PCD8544_SETBIAS | bias)?;
        Ok(())
    }

    pub fn display(&mut self) -> Result<()> {
        // TODO: Consider support for partial updates like Arduino library.
        // Reset to position zero.
        self.command(PCD8544_SETYADDR)?;
        self.command(PCD8544_SETXADDR)?;
        // Write the buffer.
        self.dc.set_value(1)?;
        self.spi.write(&self.buffer)?;
        Ok(())
    }
}
/*

    def image(self, image):
        """Set buffer to value of Python Imaging Library image.  The image should
        be in 1 bit mode and have a size of 84x48 pixels."""
        if image.mode != '1':
            raise ValueError('Image must be in mode 1.')
        index = 0
        // Iterate through the 6 y axis rows.
        // Grab all the pixels from the image, faster than getpixel.
        pix = image.load()
        for row in range(6):
            // Iterate through all 83 x axis columns.
            for x in range(84):
                // Set the bits for the column of pixels at the current position.
                bits = 0
                // Don't use range here as it's a bit slow
                for bit in [0, 1, 2, 3, 4, 5, 6, 7]:
                    bits = bits << 1
                    bits |= 1 if pix[(x, row*ROWPIXELS+7-bit)] == 0 else 0
                // Update buffer byte and increment to next byte.
                self._buffer[index] = bits
                index += 1

    def clear(self):
        """Clear contents of image buffer."""
        self._buffer = [0] * (LCDWIDTH * LCDHEIGHT // 8)
*/
